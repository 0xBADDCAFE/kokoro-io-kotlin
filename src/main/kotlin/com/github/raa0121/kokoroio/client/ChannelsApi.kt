/**
* kokoro.io API document
* X-Access-Token ヘッダーにあなたのアカウントのAPIトークンを含めることでAPIへのアクセスを行うことが出来ます。APIトークンはウェブ管理画面の右上メニュー「アカウント情報 > API情報」から確認可能です。  ただし、 POST /api/v1/devices/ APIへのリクエスト時のみ、APIトークンではなくあなたのアカウント情報を用いて認証を行うことが出来ます。この場合、X-Access-TokenではなくX-Account-Token ヘッダーを使用し、その値にはアカウントのメールアドレスとパスワードをコロンで連結した文字列 \"[email]:[password]\" を Base64 エンコードしたものを指定してください。  また、このページ右上の「Your API token here」の欄にAPIトークンを入力し「Explore」ボタンをクリックすることで、このページの各API説明部分にある「Try it out!」ボタンから実際にAPIを呼び出すことが可能になります。この時、通常のAPI呼び出しと同様、アカウントへの操作が実際に行われますのでご注意ください。 
*
* OpenAPI spec version: 1.0.0
* 
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/
package com.github.raa0121.kokoroio.client

import io.swagger.client.models.ChannelEntity
import io.swagger.client.models.ChannelWithMembershipsEntity
import io.swagger.client.models.MessageEntity

import io.swagger.client.infrastructure.*

class ChannelsApi(basePath: kotlin.String = "https://kokoro.io/api") : ApiClient(basePath) {

    /**
    * 
    * Returns public channels.
    * @param archived  (optional)
    * @return ChannelEntity
    */
    @Suppress("UNCHECKED_CAST")
    fun getV1Channels(archived: kotlin.Boolean) : ChannelEntity {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("archived" to listOf("$archived"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/v1/channels",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ChannelEntity>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ChannelEntity
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Returns a channel
    * @param channelId  
    * @return ChannelWithMembershipsEntity
    */
    @Suppress("UNCHECKED_CAST")
    fun getV1ChannelsChannelId(channelId: kotlin.Int) : ChannelWithMembershipsEntity {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/v1/channels/{channel_id}".replace("{"+"channel_id"+"}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ChannelWithMembershipsEntity>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ChannelWithMembershipsEntity
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Returns all of members in this channel
    * @param channelId  
    * @return ChannelWithMembershipsEntity
    */
    @Suppress("UNCHECKED_CAST")
    fun getV1ChannelsChannelIdMemberships(channelId: kotlin.String) : ChannelWithMembershipsEntity {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/v1/channels/{channel_id}/memberships".replace("{"+"channel_id"+"}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ChannelWithMembershipsEntity>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ChannelWithMembershipsEntity
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Returns recent messages in the channel.
    * @param channelId  
    * @param limit  (optional, default to 30)
    * @param beforeId  (optional)
    * @param afterId  (optional)
    * @return MessageEntity
    */
    @Suppress("UNCHECKED_CAST")
    fun getV1ChannelsChannelIdMessages(channelId: kotlin.String, limit: kotlin.Int, beforeId: kotlin.Int, afterId: kotlin.Int) : MessageEntity {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("limit" to listOf("$limit"), "beforeId" to listOf("$beforeId"), "afterId" to listOf("$afterId"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/v1/channels/{channel_id}/messages".replace("{"+"channel_id"+"}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<MessageEntity>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as MessageEntity
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Creates a new channel.
    * @param channelName
    * @param description
    * @param kind  (optional, default to public_channel)
    * @return ChannelEntity
    */
    @Suppress("UNCHECKED_CAST")
    fun postV1Channels(channelName: kotlin.String, description: kotlin.String, kind: kotlin.String) : ChannelEntity {
        val localVariableBody: kotlin.Any? = mapOf("channel[channel_name]" to "$channelName", "channel[description]" to "$description", "channel[kind]" to "$kind")
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/v1/channels",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ChannelEntity>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ChannelEntity
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Creates a new message.
    * @param channelId  
    * @param message  
    * @param nsfw  (optional)
    * @param idempotentKey  (optional)
    * @param expandEmbedContents  (optional)
    * @return MessageEntity
    */
    @Suppress("UNCHECKED_CAST")
    fun postV1ChannelsChannelIdMessages(channelId: kotlin.String, message: kotlin.String, nsfw: kotlin.Boolean, idempotentKey: kotlin.String, expandEmbedContents: kotlin.Boolean) : MessageEntity {
        val localVariableBody: kotlin.Any? = mapOf("message" to "$message", "nsfw" to "$nsfw", "idempotent_key" to "$idempotentKey", "expand_embed_contents" to "$expandEmbedContents")
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/v1/channels/{channel_id}/messages".replace("{"+"channel_id"+"}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<MessageEntity>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as MessageEntity
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Creates a new direct message.
    * @param targetUserProfileId  
    * @return ChannelEntity
    */
    @Suppress("UNCHECKED_CAST")
    fun postV1ChannelsDirectMessage(targetUserProfileId: kotlin.String) : ChannelEntity {
        val localVariableBody: kotlin.Any? = mapOf("target_user_profile_id" to "$targetUserProfileId")
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/v1/channels/direct_message",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ChannelEntity>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ChannelEntity
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Updates a channel.
    * @param channelId  
    * @param channelName  (optional)
    * @param description  (optional)
    * @return ChannelEntity
    */
    @Suppress("UNCHECKED_CAST")
    fun putV1ChannelsChannelId(channelId: kotlin.String, channelName: kotlin.String, description: kotlin.String) : ChannelEntity {
        val localVariableBody: kotlin.Any? = mapOf("channel[channel_name]" to "$channelName", "channel[description]" to "$description")
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/v1/channels/{channel_id}".replace("{"+"channel_id"+"}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ChannelEntity>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ChannelEntity
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Archive a channel.
    * @param channelId  
    * @return ChannelEntity
    */
    @Suppress("UNCHECKED_CAST")
    fun putV1ChannelsChannelIdArchive(channelId: kotlin.String) : ChannelEntity {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/v1/channels/{channel_id}/archive".replace("{"+"channel_id"+"}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ChannelEntity>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ChannelEntity
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Changes the authority of member
    * @param channelId  
    * @param memberId  
    * @param authority  
    * @return void
    */
    fun putV1ChannelsChannelIdManageMembersMemberId(channelId: kotlin.String, memberId: kotlin.Int, authority: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = mapOf("authority" to "$authority")
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/v1/channels/{channel_id}/manage_members/{member_id}".replace("{"+"channel_id"+"}", "$channelId").replace("{"+"member_id"+"}", "$memberId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Unarchive a channel.
    * @param channelId  
    * @return ChannelEntity
    */
    @Suppress("UNCHECKED_CAST")
    fun putV1ChannelsChannelIdUnarchive(channelId: kotlin.String) : ChannelEntity {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/v1/channels/{channel_id}/unarchive".replace("{"+"channel_id"+"}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ChannelEntity>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ChannelEntity
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

}
